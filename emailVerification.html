<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    <style>
        code{
            background-color: rgba(0,0,0,.075);
            font-weight: bold;
        }
        .subtitle{
            font-size: 1.3rem;
            font-weight: bold;
            margin: 0;
            padding: 5px;
            margin-top: 5px;
            background-color: rgba(0,0,0,.075);
            text-align: center;
        }
        h3{
            font-size: 2rem;
            font-weight: bold;
            margin: 0;
            padding: 5px;
            margin-top: 10px;
        }
        .paragraph{
            margin: 0.5rem 0 0.5rem;
        }
        .tab{
            margin: 0 1rem;
        }
        </style>

    <title>Email Verification in Node, Express, and MongoDB</title>
  </head>
  <body>
      
    <div class="container">
        <h1 class="display-3 text-center">Email Verification in Node, Express, and MongoDB<hr></h1>
        <header>
            <p class="paragraph">
                This is a study into the implementation of Email verification for users from <a href="https://codemoto.io/coding/nodejs/email-verification-node-express-mongodb" target="_blank">Codemoto (Article link)</a>. Email verification is essential for ensuring signups are from real users. This article assumes that you already have an express app up and running, I will start by doing that. I set up a new db in MongoDBAtlas and created a repo in github: <a href="https://github.com/Marlrus/EmailVerificationTesting" target="_blank">Email Verification Testing</a>
            </p>
        </header>
        <ul class="list-group">
            <li class="list-group-item">
                <h2 class="subtitle">Intro</h2>
                <p class="paragraph">
                    We will do the following workflow: 1- A user registers for an account. The user is created, but the user still needs to be verified via an email confirmation. The user cannot login until their account is verified. 2- A verification token is emailed to the user. 3- The user receives the verification email in their inbox. A link is provided in the email that passes the verification token back into your app.
                </p>
            </li>
            <li class="list-group-item">
                <h2 class="subtitle">Creating Your Models</h2>
                <p class="paragraph">
                    <strong>Tracking Verification</strong>
                    <br>
                    To support email verification there must be some things in your user model. To distinguis verified and unverified users we need to add a <code>is_verified</code> flag to the User model with the default value ser to false. 
                </p> 
                <p class="paragraph">
                    <strong>Create Token Verification Model</strong>
                    <br>
                    When a user signs up, we need to create a verification token within Mongo. We need a new modle to handle our verification tokens. You will need to provide the userID of the user for the token that is used. There is a powerful feature in Mongo called <em>'expires'</em> that sets a document's time to live, known as TTL. It is set to 43200 seconds, meaning the verification token document will automatically delete itself after 12 hours. This means the user has 12 hours to activate their accounts before their verification tokens expire. If a user doesn't confirm their accounts in time, they can requiest a new verification token. 
                </p>   
            </li>
            <li class="list-group-item">
                <h2 class="subtitle">Passport-Local and Passport-local-mongoose</h2>
                <p class="paragraph">
                    This tutorial assumes you have things set-up. I set up things using passport-local and passport-local-mongoose to handle the salt, hash, and password creation and validation. There is a very fixed way passport-local-mongoose works and I changed its behavior using 2 lines of code. In the local-p-setup.js configuration file <code>passport.use(User.createStrategy())</code> overrides the standard static auth method. It allows you to specify an alternative usernameField (passport-local-mongoose requires a field called username in your form to function), in our case 'email' instead of username. To enable this we go into the user.js file and use <code>UserSchema.plugin(passportLocalMongoose, { usernameField: 'email'})</code> and in our route we use <code>User.register(new User({email: req.body.email}), req.body.password, (err,user)=>{}</code> allowing us to use the <code>register()</code> method with email instead of username. 
                </p>
            </li>
        </ul>
    </div>

    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
    </body>
</html>